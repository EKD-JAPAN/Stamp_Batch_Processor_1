<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-One eBay 画像加工ツール</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZipライブラリ (ZIPファイル作成用) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* カスタムスタイル: PC向け横長レイアウトに最適化 */
        :root {
            --color-primary: #4A5568; 
            --color-accent: #4299E1;  /* Zero-One Blue */
            --color-success: #10B981; /* Green */
        }
        .card {
            background-color: white;
            border-radius: 1rem; /* 16px */
            box-shadow: 0 4px 10px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -2px rgba(0, 0, 0, 0.04);
        }
        
        /* 3x5グリッドの外枠 */
        .grid-container-3x5 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(5, 1fr);
            position: relative;
        }

        /* 39点の配置を可能にするためのオーバーレイ */
        .placement-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; 
        }

        /* 個々の配置可能点 (39点) */
        .placement-point {
            position: absolute;
            pointer-events: auto; /* クリック可能にする */
            transition: all 0.1s ease-in-out;
            z-index: 10;
        }

        /* 配置点の可視化とインタラクション */
        .dot {
            position: absolute;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #718096; /* Gray border */
            background-color: white;
            opacity: 0.6;
            cursor: pointer;
            transition: all 0.1s;
        }

        .placement-point:hover .dot {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.5);
            background-color: var(--color-accent);
            border-color: var(--color-accent);
            box-shadow: 0 0 5px var(--color-accent);
        }

        .placement-point.selected .dot {
            opacity: 1;
            transform: translate(-50%, -50%) scale(2.0);
            background-color: var(--color-accent);
            border: 2px solid white;
            box-shadow: 0 0 8px rgba(66, 153, 225, 0.8);
        }

        /* 補助線 (3x5のグリッド線) の描画 */
        .grid-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(5, 1fr);
            border: 2px solid #CBD5E0; /* 外部枠 */
            border-radius: 1rem;
            pointer-events: none;
            overflow: hidden;
        }
        .grid-overlay > div {
            border: 1px solid #E2E8F0; /* 内部線 */
        }
        
        /* ツールチップ風のラベル */
        .label {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            padding: 2px 8px;
            background-color: var(--color-accent);
            color: white;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
        }
        .placement-point:hover .label {
            opacity: 1;
            transform: translateX(-50%) translateY(-150%);
        }

        /* プレビューセレクターのタブスタイル */
        .preview-tab {
            padding: 8px 12px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            border-radius: 0.5rem 0.5rem 0 0;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 500;
        }
        .preview-tab:hover {
            background-color: #E2E8F0; /* Gray-200 */
        }
        .preview-tab.selected {
            background-color: white;
            color: var(--color-accent);
            border-color: var(--color-accent);
            font-weight: 700;
        }

    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Noto Sans JP', 'sans-serif'],
                    },
                    colors: {
                        'primary-accent': '#4299E1',
                        'secondary-gray': '#718096',
                        'zero-one-blue': '#4299E1', 
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 font-sans min-h-screen p-4 sm:p-6 lg:p-10">

    <!-- メインコンテナ: 最大幅を設定し、中央寄せにする -->
    <div class="w-full mx-auto max-w-7xl">
        <header class="mb-6 border-b border-gray-200 pb-3">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-800 tracking-tight">Zero-One eBay 画像加工ツール</h1>
            <p class="text-secondary-gray mt-1 text-sm sm:text-base">eBay出品画像にロゴやスタンプを配置し合成するツールです。</p>
        </header>

        <!-- メインコンテンツエリア: 左右分割 (設定/プレビュー) -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 lg:gap-8">
            
            <!-- LEFT: 設定パネル (lg:col-span-5 -> 約41%幅) -->
            <div class="lg:col-span-5 flex flex-col gap-6">

                <!-- スクールロゴ＆リンクエリア -->
                <a href="https://drive.google.com/drive/folders/1sPwDa8j3QPQgwz4EXJJpJj0TolNDCFdC?usp=drive_link" target="_blank" class="card p-4 bg-zero-one-blue hover:bg-blue-600 transition duration-150 shadow-md flex items-center justify-center text-white font-semibold text-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                    </svg>
                    <span>推奨スタンプ画像フォルダ (Google Drive)</span>
                </a>

                <!-- 1. 画像アップロード -->
                <div class="card p-6">
                    <h2 class="text-xl font-bold mb-4 text-gray-700 flex items-center">
                        <span class="text-zero-one-blue mr-2 font-extrabold">1.</span> 画像の選択
                    </h2>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">元画像 (複数選択可)</label>
                        <!-- multiple属性を追加 -->
                        <input type="file" id="originalImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:text-white file:bg-zero-one-blue hover:file:bg-blue-600 transition duration-150 cursor-pointer">
                        <p id="originalFileStatus" class="mt-2 text-xs text-gray-400">0 ファイル選択中</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">スタンプ画像 (ロゴ/透かし PNG)</label>
                        <input type="file" id="stampImageUpload" accept="image/png" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:text-white file:bg-pink-500 hover:file:bg-pink-600 transition duration-150 cursor-pointer">
                        <p id="stampFileNameDisplay" class="mt-2 text-xs text-gray-400">スタンプ未選択</p>
                    </div>
                </div>

                <!-- 2. 配置グリッド（3x5分割法 + 交点） -->
                <div class="card p-6">
                    <h2 class="text-xl font-bold mb-4 text-gray-700 flex items-center">
                        <span class="text-zero-one-blue mr-2 font-extrabold">2.</span> 配置場所
                    </h2>
                    <p class="text-sm text-gray-500 mb-3">スタンプの中心位置を選択してください（四隅や境界線上の配置も可能です）。この設定は全ての元画像に適用されます。</p>
                    
                    <!-- 3x5グリッドの外枠とオーバーレイのコンテナ -->
                    <div id="placementArea" class="relative w-full h-64 sm:h-80 rounded-xl overflow-hidden bg-white">
                        <!-- 3x5グリッドの補助線 -->
                        <div class="grid-overlay">
                            <!-- 15個の仮想セルを描画 (線を見やすくするため) -->
                            <div></div><div></div><div></div>
                            <div></div><div></div><div></div>
                            <div></div><div></div><div></div>
                            <div></div><div></div><div></div>
                            <div></div><div></div><div></div>
                        </div>

                        <!-- 39点のクリック可能なオーバーレイ -->
                        <div id="placementOverlay" class="placement-overlay">
                            <!-- 39個の placement-point がJSによって挿入されます -->
                        </div>
                    </div>
                </div>

                <!-- 3. サイズ設定と操作 -->
                <div class="card p-6 flex flex-col justify-between">
                     <div>
                        <h2 class="text-xl font-bold mb-4 text-gray-700 flex items-center">
                            <span class="text-zero-one-blue mr-2 font-extrabold">3.</span> サイズ調整
                        </h2>
                        <label for="stampSize" class="block text-sm font-medium text-gray-700">元画像幅に対する割合 (%)</label>
                        <div class="flex items-center mt-2">
                            <input type="range" id="stampSize" min="5" max="50" value="15" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg accent-zero-one-blue" title="スタンプサイズ調整スライダー">
                            <span id="sizeValue" class="ml-4 w-12 text-center text-lg font-bold text-zero-one-blue">15%</span>
                        </div>
                        <p class="mt-2 text-xs text-gray-500">この設定は全ての元画像に適用されます。</p>
                     </div>

                     <div class="mt-6">
                         <button id="applySettings" class="w-full py-3 px-4 bg-zero-one-blue hover:bg-blue-600 text-white font-bold rounded-xl shadow-lg transition duration-150 transform hover:scale-[1.01] disabled:bg-gray-300 disabled:cursor-not-allowed text-lg" disabled>
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                                 <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                                 <path d="M7 12l5 5l10 -10" />
                                 <path d="M2 12l5 5" />
                             </svg>
                             プレビューを更新
                         </button>
                         <p id="errorMessage" class="text-red-500 mt-3 text-sm text-center hidden">※元画像とスタンプ画像の両方を選択してください。</p>
                     </div>
                </div>
            </div>

            <!-- RIGHT: プレビュー & ダウンロードエリア (lg:col-span-7 -> 約58%幅) -->
            <div class="lg:col-span-7 flex flex-col gap-6">
                <div class="card p-6 flex-grow flex flex-col">
                    <h2 class="text-xl font-bold mb-4 text-gray-700 flex items-center">
                        <span class="text-zero-one-blue mr-2 font-extrabold">4.</span> プレビューとダウンロード
                    </h2>

                    <!-- プレビュー画像切り替えタブ -->
                    <div id="previewSelector" class="flex overflow-x-auto border-b border-gray-200 bg-gray-100 rounded-t-xl mb-0 p-1">
                        <!-- タブボタンはJSで挿入されます -->
                    </div>
                    
                    <div id="canvasContainer" class="relative w-full mx-auto shadow-2xl rounded-b-xl overflow-hidden bg-gray-200 flex justify-center items-center border-4 border-gray-100 flex-grow" style="min-height: 250px; aspect-ratio: 16 / 9;">
                        <!-- プレビューキャンバスがここに配置されます -->
                        <canvas id="previewCanvas" class="w-full h-auto"></canvas>
                        <p id="canvasPlaceholder" class="absolute text-gray-500 text-lg p-10 text-center">元画像とスタンプ画像をアップロードし、「プレビューを更新」ボタンを押して確認してください。</p>
                    </div>
                    
                    <!-- ダウンロードボタン群 -->
                    <div class="mt-6 flex flex-col sm:flex-row gap-4 justify-center items-center">
                        <!-- ZIP一括ダウンロードボタン -->
                        <button id="downloadZipButton" class="w-full sm:w-1/2 py-4 px-6 bg-pink-500 hover:bg-pink-600 text-white font-bold rounded-xl shadow-xl transition duration-300 transform hover:scale-[1.03] disabled:bg-gray-300 disabled:cursor-not-allowed text-base sm:text-lg" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 17v4" /><path d="M10 20l2 2l2 -2" /><path d="M12 3v4" /><path d="M10 6l2 -2l2 2" /><path d="M7 12h4" /><path d="M13 12h4" /><path d="M5 5m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z" />
                            </svg>
                            全ファイル一括ダウンロード (ZIP)
                        </button>

                        <!-- 個別ダウンロードボタン -->
                        <button id="downloadSingleButton" class="w-full sm:w-1/2 py-4 px-6 bg-zero-one-blue hover:bg-blue-600 text-white font-bold rounded-xl shadow-xl transition duration-300 transform hover:scale-[1.03] disabled:bg-gray-300 disabled:cursor-not-allowed text-base sm:text-lg" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            プレビュー中の画像をダウンロード (JPEG)
                        </button>
                    </div>
                </div>
            </div>

        </div>

        <footer class="mt-8 pt-4 border-t border-gray-200 text-center text-sm text-secondary-gray">
            <p>&copy; Zero-One スクール専用ツール | Powered by Gemini</p>
        </footer>

    </div>

    <script>
        // グローバル変数と定数
        const GRID_COLS = 3; // 3x5グリッドの横分割数
        const GRID_ROWS = 5; // 3x5グリッドの縦分割数

        // 39点すべての配置座標を計算 (xRatio, yRatio)
        const REAL_POSITIONS = []; 
        let index = 0;

        // 4x6=24個の交点 (Junction)
        for (let j = 0; j <= GRID_ROWS; j++) { // j=0 to 5 (6行)
            const yRatio = j / GRID_ROWS;
            for (let i = 0; i <= GRID_COLS; i++) { // i=0 to 3 (4列)
                const xRatio = i / GRID_COLS;
                
                REAL_POSITIONS.push({
                    xRatio: xRatio,
                    yRatio: yRatio,
                    type: 'Junction',
                    index: index++
                });
            }
        }

        // 3x5=15個のセル中心 (Center)
        for (let j = 0; j < GRID_ROWS; j++) {
            const yRatio = (j + 0.5) / GRID_ROWS; 
            for (let i = 0; i < GRID_COLS; i++) {
                const xRatio = (i + 0.5) / GRID_COLS; 
                
                 REAL_POSITIONS.push({
                    xRatio: xRatio,
                    yRatio: yRatio,
                    type: 'Center',
                    index: index++
                });
            }
        }
        
        
        let originalImageFiles = [];    // 元画像のファイルオブジェクト配列 (ダウンロード用ファイル名保持)
        let originalImageObjects = [];  // 元画像のImageオブジェクト配列 (描画用)
        let stampImage = null;          // スタンプ画像 (Imageオブジェクト)
        
        let currentPreviewIndex = 0;    // 現在プレビュー中の画像インデックス
        let selectedPositionIndex = 3;  // 初期位置は右上角 (Junction: index 3) に設定
        let stampSizeRatio = 0.15;      // 初期サイズは15%

        // DOM要素
        const originalImageUpload = document.getElementById('originalImageUpload');
        const stampImageUpload = document.getElementById('stampImageUpload');
        const originalFileStatus = document.getElementById('originalFileStatus');
        const stampFileNameDisplay = document.getElementById('stampFileNameDisplay');
        const placementOverlay = document.getElementById('placementOverlay');
        const stampSizeRange = document.getElementById('stampSize');
        const sizeValueSpan = document.getElementById('sizeValue');
        const applySettingsButton = document.getElementById('applySettings');
        const errorMessage = document.getElementById('errorMessage');
        const canvas = document.getElementById('previewCanvas');
        const ctx = canvas.getContext('2d');
        const canvasPlaceholder = document.getElementById('canvasPlaceholder');
        const canvasContainer = document.getElementById('canvasContainer'); 
        const downloadSingleButton = document.getElementById('downloadSingleButton'); 
        const downloadZipButton = document.getElementById('downloadZipButton'); 
        const previewSelector = document.getElementById('previewSelector');

        // ====================================================================
        // ユーティリティ関数
        // ====================================================================

        /**
         * 状態に応じてボタンの有効/無効を切り替えます。
         */
        function updateButtonStates() {
            const hasOriginals = originalImageObjects.length > 0;
            const canApply = hasOriginals && stampImage;
            
            applySettingsButton.disabled = !canApply;
            downloadSingleButton.disabled = !canApply;
            downloadZipButton.disabled = !canApply || originalImageObjects.length <= 1; // 1枚以下ならZIPは不要

            errorMessage.classList.toggle('hidden', canApply);
            if (canApply) {
                errorMessage.textContent = "";
            } else {
                 errorMessage.textContent = "※元画像とスタンプ画像の両方を選択してください。";
            }
        }

        /**
         * ファイルを読み込み、Imageオブジェクトとして返すPromise
         * @param {File} file - 読み込むファイル
         * @returns {Promise<Image>} Imageオブジェクト
         */
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                if (!file) return reject("No file provided.");
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject("Failed to load image.");
                    img.src = event.target.result;
                };
                reader.onerror = () => reject("FileReader failed.");
                reader.readAsDataURL(file);
            });
        }

        // ====================================================================
        // 描画処理
        // ====================================================================

        /**
         * 指定されたインデックスの画像をキャンバスにレンダリングします。
         * @param {number} index - プレビューする画像のインデックス
         */
        function renderCanvas(index = currentPreviewIndex) {
            const originalImage = originalImageObjects[index];

            if (!originalImage) {
                canvasPlaceholder.textContent = "元画像とスタンプ画像をアップロードし、「プレビューを更新」ボタンを押して確認してください。";
                canvasPlaceholder.classList.remove('hidden');
                canvasContainer.style.aspectRatio = '16 / 9'; 
                return;
            }

            // Canvasサイズを元画像のネイティブサイズに合わせる
            canvas.width = originalImage.naturalWidth;
            canvas.height = originalImage.naturalHeight;
            
            // CSSでアスペクト比を設定
            canvasContainer.style.aspectRatio = `${canvas.width} / ${canvas.height}`;

            // 1. 元画像の描画 (JPEG保存のため白背景を確保)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            // 2. スタンプの描画 (スタンプ画像が読み込まれている場合)
            if (stampImage) {
                // drawStamp関数に描画先のコンテキスト(ctx)を渡す
                drawStamp(ctx, originalImage, stampImage, canvas.width, canvas.height);
            }

            canvasPlaceholder.classList.add('hidden');
        }

        /**
         * 指定されたキャンバスコンテキストにスタンプを描画するコアロジック。
         * @param {CanvasRenderingContext2D} targetCtx - 描画先のコンテキスト
         * @param {Image} originalImg - 元画像Imageオブジェクト
         * @param {Image} stampImg - スタンプImageオブジェクト
         * @param {number} canvasW - 描画先の幅
         * @param {number} canvasH - 描画先の高さ
         */
        function drawStamp(targetCtx, originalImg, stampImg, canvasW, canvasH) {
             // スタンプのターゲットサイズ (元画像幅に対する割合)
            const stampWidth = canvasW * stampSizeRatio;
            // アスペクト比を維持して高さを計算
            const stampHeight = stampWidth * (stampImg.naturalHeight / stampImg.naturalWidth);

            // 選択された位置の座標を取得
            const pos = REAL_POSITIONS.find(p => p.index === selectedPositionIndex);
            if (!pos) return;

            // スタンプの中心座標 (Cx, Cy)
            const centerX = canvasW * pos.xRatio;
            const centerY = canvasH * pos.yRatio;

            // 描画開始座標 (左上) を計算 (Cx - W/2, Cy - H/2)
            const drawX = centerX - (stampWidth / 2);
            const drawY = centerY - (stampHeight / 2);

            // スタンプの描画
            targetCtx.drawImage(stampImg, drawX, drawY, stampWidth, stampHeight);
        }

        // ====================================================================
        // プレビュー選択UIの構築
        // ====================================================================

        /**
         * プレビュー切り替え用のタブUIを構築します。
         */
        function createPreviewSelector() {
            previewSelector.innerHTML = '';
            
            originalImageFiles.forEach((file, i) => {
                const tab = document.createElement('div');
                tab.className = `preview-tab text-sm text-gray-700 ${i === currentPreviewIndex ? 'selected' : ''}`;
                tab.textContent = file.name;
                tab.dataset.index = i;
                tab.title = file.name;

                tab.addEventListener('click', () => {
                    setCurrentPreview(i);
                });

                previewSelector.appendChild(tab);
            });
            
            // 選択中のタブが見えるようにスクロール
            const selectedTab = previewSelector.querySelector('.preview-tab.selected');
            if (selectedTab) {
                selectedTab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }
        }
        
        /**
         * プレビュー対象を切り替えます。
         * @param {number} index - 新しいプレビューインデックス
         */
        function setCurrentPreview(index) {
            if (index === currentPreviewIndex || index < 0 || index >= originalImageObjects.length) return;

            currentPreviewIndex = index;

            // タブの選択状態を更新
            document.querySelectorAll('.preview-tab').forEach(tab => {
                tab.classList.remove('selected');
                if (parseInt(tab.dataset.index) === index) {
                    tab.classList.add('selected');
                }
            });

            // キャンバスを再描画
            renderCanvas();
        }


        // ====================================================================
        // 配置グリッドの初期化 (リサイズ対応)
        // ====================================================================

        /**
         * 39点配置グリッドの初期化
         * 画面サイズ変更時、配置エリアのサイズに応じて点の位置を再計算し配置し直します。
         */
        function initializePlacementGridCorrected() {
            placementOverlay.innerHTML = '';
            
            const placementArea = document.getElementById('placementArea');
            // DOM要素の現在のサイズを取得
            const gridWidth = placementArea.offsetWidth;
            const gridHeight = placementArea.offsetHeight;

            REAL_POSITIONS.forEach(pos => {
                // 絶対座標を計算
                const x = pos.xRatio * gridWidth;
                const y = pos.yRatio * gridHeight;
                
                const pointContainer = document.createElement('div');
                pointContainer.className = 'placement-point';
                pointContainer.dataset.index = pos.index;
                pointContainer.dataset.type = pos.type;
                
                // 絶対位置で配置する
                pointContainer.style.position = 'absolute';
                // x, y 座標に配置
                pointContainer.style.left = `${x}px`;
                pointContainer.style.top = `${y}px`;
                pointContainer.style.width = '1px'; // ダミー幅
                pointContainer.style.height = '1px'; // ダミー高さ
                
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.style.position = 'absolute';
                dot.style.left = '0';
                dot.style.top = '0';

                const label = document.createElement('span');
                label.className = 'label';
                
                // 選択可能な点であることを示すラベル（シンプル化）
                label.textContent = pos.type === 'Junction' ? '交点' : '中心';
                
                pointContainer.appendChild(dot);
                pointContainer.appendChild(label);

                // 初期位置を選択状態にする
                if (pos.index === selectedPositionIndex) {
                    pointContainer.classList.add('selected');
                }

                pointContainer.addEventListener('click', (e) => {
                    e.stopPropagation(); // 重なり防止
                    // 全ての点から選択状態を解除
                    document.querySelectorAll('#placementOverlay .placement-point').forEach(c => c.classList.remove('selected'));

                    // クリックされた点を選択状態に
                    pointContainer.classList.add('selected');
                    selectedPositionIndex = pos.index;

                    // 位置が変更されたら即座に再描画
                    if (originalImageObjects.length > 0 && stampImage) {
                        renderCanvas();
                    }
                });
                placementOverlay.appendChild(pointContainer);
            });
        }


        // ====================================================================
        // イベントハンドラ
        // ====================================================================

        /**
         * 元画像アップロード時の処理（複数ファイル対応）
         */
        originalImageUpload.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            originalImageFiles = files;
            originalImageObjects = [];
            currentPreviewIndex = 0; // ファイルが変わったらインデックスをリセット

            if (files.length > 0) {
                originalFileStatus.textContent = `${files.length} ファイル選択中`;
                
                // 読み込み中のインジケータ表示
                canvasPlaceholder.textContent = `画像を読み込み中... (0/${files.length})`;
                canvasPlaceholder.classList.remove('hidden');
                
                for (let i = 0; i < files.length; i++) {
                     try {
                        const img = await loadImage(files[i]);
                        originalImageObjects.push(img);
                        canvasPlaceholder.textContent = `画像を読み込み中... (${i+1}/${files.length})`;
                    } catch (error) {
                        console.error(`画像 ${files[i].name} の読み込みエラー:`, error);
                    }
                }
                // プレビューセレクターを構築
                createPreviewSelector();
                // 最初の画像をプレビュー
                renderCanvas(currentPreviewIndex); 
            } else {
                originalFileStatus.textContent = `0 ファイル選択中`;
                originalImageFiles = [];
                originalImageObjects = [];
                previewSelector.innerHTML = '';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvasPlaceholder.classList.remove('hidden');
            }
            updateButtonStates();
        });

        /**
         * スタンプ画像アップロード時の処理
         */
        stampImageUpload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    stampImage = await loadImage(file);
                    stampFileNameDisplay.textContent = `選択中のスタンプ: ${file.name}`;
                } catch (error) {
                    console.error("スタンプ画像の読み込みエラー:", error);
                    stampImage = null;
                    stampFileNameDisplay.textContent = "スタンプ画像の読み込みに失敗しました。";
                }
            } else {
                stampImage = null;
                stampFileNameDisplay.textContent = "スタンプ未選択";
            }
            updateButtonStates();
        });


        /**
         * サイズスライダーの値変更時の処理
         */
        stampSizeRange.addEventListener('input', (e) => {
            const size = e.target.value;
            sizeValueSpan.textContent = `${size}%`;
            stampSizeRatio = size / 100;
             // サイズが変更されたら即座に再描画（使いやすさ向上のため）
            if (originalImageObjects.length > 0 && stampImage) {
                 renderCanvas();
            }
        });

        /**
         * 設定適用ボタンクリック時の処理
         */
        applySettingsButton.addEventListener('click', () => {
            if (originalImageObjects.length > 0 && stampImage) {
                renderCanvas();
            }
        });
        
        /**
         * 個別ダウンロードボタンクリック時の処理 (プレビュー中の画像をJPEGでダウンロード)
         */
        downloadSingleButton.addEventListener('click', () => {
            const originalFile = originalImageFiles[currentPreviewIndex];
            if (originalImageObjects.length > 0 && stampImage && originalFile) {
                // プレビュー中のキャンバスの内容を取得
                // 既にrenderCanvasが最新の状態なので、そのままダウンロード処理へ進む
                
                const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                
                // ファイル名を決定: [元のファイル名]_stamp.jpeg
                const baseName = originalFile.name.replace(/\.[^/.]+$/, ""); // 拡張子を除去
                const downloadFileName = `${baseName}_stamp.jpeg`;

                // ダウンロードを実行
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = downloadFileName; 
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        });

        /**
         * ZIP一括ダウンロードボタンクリック時の処理
         */
        downloadZipButton.addEventListener('click', async () => {
            if (originalImageObjects.length === 0 || !stampImage) {
                return;
            }

            // UIを更新して処理中であることを示す
            downloadZipButton.disabled = true;
            const originalHtml = downloadZipButton.innerHTML;
            downloadZipButton.innerHTML = '<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>ZIP作成中...';


            const zip = new JSZip();

            for (let i = 0; i < originalImageObjects.length; i++) {
                const originalImg = originalImageObjects[i];
                const originalFile = originalImageFiles[i];
                
                // テンポラリキャンバスで合成画像を作成
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = originalImg.naturalWidth;
                tempCanvas.height = originalImg.naturalHeight;
                
                // 1. 元画像の描画 (JPEG保存のため白背景を確保)
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(originalImg, 0, 0, tempCanvas.width, tempCanvas.height);

                // 2. スタンプの描画（**修正点: tempCtxを使用**）
                // drawStamp関数に描画先のコンテキスト(tempCtx)を渡す
                drawStamp(tempCtx, originalImg, stampImage, tempCanvas.width, tempCanvas.height); 

                // JPEGデータURLを取得
                const dataURL = tempCanvas.toDataURL('image/jpeg', 0.9);
                const base64Data = dataURL.split(',')[1];
                
                // ファイル名を決定: [元のファイル名]_stamp.jpeg
                const baseName = originalFile.name.replace(/\.[^/.]+$/, ""); 
                const fileName = `${baseName}_stamp.jpeg`;
                
                zip.file(fileName, base64Data, { base64: true });
            }

            // ZIPファイルを生成しダウンロード
            zip.generateAsync({ type: "blob" })
                .then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = "ebay_stamped_images.zip";
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url); 

                    // ボタンを元に戻す
                    downloadZipButton.disabled = false;
                    downloadZipButton.innerHTML = originalHtml;
                })
                .catch((e) => {
                     console.error("ZIPファイルの作成に失敗しました", e);
                     downloadZipButton.disabled = false;
                     downloadZipButton.innerHTML = 'ダウンロードエラー';
                });
        });


        // ====================================================================
        // 初期化
        // ====================================================================

        window.onload = () => {
            const placementArea = document.getElementById('placementArea');
            
            // サイズ変更時のリセット処理
            // コンテナのサイズに合わせて点を再配置するために必要
            const resizeObserver = new ResizeObserver(() => {
                 // プレースメントエリアのサイズが変わるたびに点を再描画
                 initializePlacementGridCorrected();
            });

            // placementAreaのサイズ変更を監視
            resizeObserver.observe(placementArea);

            updateButtonStates();
            canvasContainer.style.aspectRatio = '16 / 9'; // 初期状態でのアスペクト比
            
            // 初回描画も実行（初期位置の点表示のため）
            initializePlacementGridCorrected();
        };
    </script>
</body>
</html>
